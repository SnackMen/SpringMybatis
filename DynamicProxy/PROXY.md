# 静态代理和动态代理
* ##### java动态代理机制出现好处：开发人员不需要使用类似于代理模式那样，手写代理类；只需要简单地指定一组接口以及委托类对象，便能动态地获取代理类。
> #### 静态代理
##### 由程序员创建或特定工具自动生成源代码，再对其编译，在程序运行前，代理类的.class文件就已经存在了
##### 原理:对普通一个借口与一直实现类再加入一个代理类，用于包装实现类中实现的方法，而业务使用方只需要实例化代理类，并传递需要代理的普通类
##### 优点：编译时生成代码，运行时不需要再考虑这些，性能高
##### 缺点:
* ###### 有一个代理类只能为一个借口提供服务，开发中必然会产生过多的代理
* ###### 所有的代理操作除了调用的方法不一样外，其他的操作都是一样的，此时肯定会出现重复代码
> #### 动态代理
##### 动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码
##### 优点：可以通过一个代理类完成所有的工作，不需要再像静态代理一样需要一个一个实现接口来代理
##### 缺点：通过反射机制代理方法将消耗系统性能，如果非常多的话，性能非常低
> #### jdk动态代理
##### 只能代理实现了接口的类，不能实现接口的类就不能实现jdk动态代理
##### jdk动态代理类可以将实现了InvocationHandler接口的子类想象成一个代理的最终操作类，即在这里面针对其他类或方法进行代理
> #### CGLIB动态代理
##### 针对类来实现代理，针对指定的目标类生成一个子类，并覆盖其中的方法实现增强效果，但是因为是采用的继承，所以不能针对final修饰的类进行代理。
> #### 类加载器：加载java类到java虚拟机中。
##### java虚拟机使用Java类的方式如下：Java源程序(.java)在经过Java编译器之后就被转换成Java字节码文件(.class).类加载器读取Java字节代码并转换成java.lang.Class类的一个实例。每一个这样的实例用来表示一个Java类，通过此实例的newInstance方法可以创建出该类的对象。基本上所有的类加载器都是java.lang.ClassLoader类的一个实例类加载器职责：依据一个指定类的名称，找到或者生成其对应的字节代码(.class)，然后从这些字节代码中定义出一个Java类(怎么定义的？)除此之外，ClassLoader还负责加载java应用所需资源，如图像文件和配置文件